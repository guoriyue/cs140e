# Operating Systems Design and Implementation

## Why should I take CS 140E?

CS 140E is unlike many other Stanford CS classes in one major way: it isn't
simplified for a classroom setting. The hardware you're interacting with is the
same hardware the Linux kernel interacts with. When there's a bug in the
hardware, we have to work around it. When the documents are wrong, we have to
find the errors.

- If the freedom to design any embedded system you can imagine excites you, CS
  140E is one of the only places you can do it in a classroom setting.
- If you've never programmed in a completely baremetal system before, CS 140E
  will give you a taste of what it's like.
- If you want to get better at debugging, CS 140E will give you plenty of
  opportunities to do so.
- If you want to get better at real-world systems programming, CS 140E gives
  you the chance to work on raw hardware and documents, rather than
  a simplified simulation.

## Who should take CS 140E?

This is a tricky question, since there's no one particular set of factors which
is correlated with success in this class. There's a subset of people who love
it, and a subset who don't.

In general, the people who enjoy CS 140E tend to fit the following:

1.  One of:
    - You write code well
    - You want to learn to write code well, and have a lot of time to devote to
      the class
2.  You find systems topics interesting

However, since the class is fairly unusual in a lot of ways, it also tends to
appeal to people from atypical backgrounds. Some of our most successful
students in the past have been from non-CS majors. As mentioned below, we don't
have any hard prerequisites; this is specifically because we want the course to
be accessible to anyone who's interested in learning the material, regardless
of background.

## What are the differences between CS 212 and CS 140E?

CS 140E can count as a substitute for CS 212 (including for PhD students who
need to fulfill an OS breadth requirement). It is approximately 80% of the
_coding_ work of CS 212, but will probably require a more strenuous type of
thinking at some points. The main differences are:

1.  We work with raw hardware (the Raspberry Pi A+), not a simulator.
2.  Most of the reading involves primary hardware documents, rather than
    high-level discussions.
3.  Most of the code at the end will (hopefully) be written by you, rather than
    you having to deal with a large, complicated codebase.
4.  We focus much more on checking and somewhat-verifying your code,
    rather than passing an autograder.

With that said, you are strongly encouraged to sit in on the CS 212 lectures if
you can; Mazi√®res is incredibly knowledgable, and will serve as a great
counterpoint to what we do.

The flip side of working with raw hardware and documentation is that this class
is much less structured than other CS classes you might have taken before. If
you're the kind of person who loves figuring things out and exploring, great!
If you prefer more structured assignments and lectures, you might want to
consider CS 212 instead.

## Recommended Prerequisites

Note that nothing here is strictly required, as long as you're willing to learn
it on-the-fly. However, the course material is designed assuming most students
will have the following:

- CS 110 or CS 111
- Some knowledge of C and UNIX

No previous experience with operating systems, raspberry pis, or embedded
programming is required.

If you want to take the course but are worried about any of these, talk to us!
We can point you to resources to help catch up, should you need them.
