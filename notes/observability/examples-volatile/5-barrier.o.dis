
5-barrier.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 <barrier_store>:
int barrier_store(int *p) { 
    *p = 1;
   0:	e3a03001 	mov	r3, #1, 0
   4:	e5803000 	str	r3, [r0]
    asm volatile ("" : : : "memory");
    return *p;
}
   8:	e5900000 	ldr	r0, [r0]
   c:	e12fff1e 	bx	lr

00000010 <no_barrier_store>:

int no_barrier_store(int *p) { 
    *p = 1;
  10:	e3a03001 	mov	r3, #1, 0
  14:	e5803000 	str	r3, [r0]
    return *p;
}
  18:	e1a00003 	mov	r0, r3
  1c:	e12fff1e 	bx	lr

00000020 <call_ptr>:
extern void bar(void);


// p escapes: forces to memory and back.
int call_ptr(int *p) {
    *p = 1;
  20:	e3a03001 	mov	r3, #1, 0
int call_ptr(int *p) {
  24:	e92d4010 	push	{r4, lr}
  28:	e1a04000 	mov	r4, r0
    *p = 1;
  2c:	e5803000 	str	r3, [r0]
    bar();
  30:	ebfffffe 	bl	0 <bar>
    return *p;
}
  34:	e5940000 	ldr	r0, [r4]
  38:	e8bd4010 	pop	{r4, lr}
  3c:	e12fff1e 	bx	lr

00000040 <call_local>:

// x does not escape: replaces with 1.
int call_local(void) {
  40:	e92d4010 	push	{r4, lr}
    int x = 1;
    bar();
  44:	ebfffffe 	bl	0 <bar>
    return x;
}
  48:	e3a00001 	mov	r0, #1, 0
  4c:	e8bd4010 	pop	{r4, lr}
  50:	e12fff1e 	bx	lr

00000054 <disable>:

// gcc does not obey no inline??
__attribute__ ((__noinline__)) unsigned disable(void) {
    // disable interrupts
    unsigned t;
    asm volatile("mrs %0,cpsr; orr %0,%0,#(1<<7); msr cpsr_c,%0" : "=r"(t));
  54:	e10f0000 	mrs	r0, CPSR
  58:	e3800080 	orr	r0, r0, #128, 0	; 0x80
  5c:	e121f000 	msr	CPSR_c, r0
    return t;
}
  60:	e12fff1e 	bx	lr

00000064 <enable>:
__attribute__ ((__noinline__)) unsigned enable(void) {
    // enable interrupts
    unsigned t;
    asm volatile("mrs %0,cpsr; bic %0,%0,#(1<<7); msr cpsr_c,%0" : "=r"(t));
  64:	e10f0000 	mrs	r0, CPSR
  68:	e3c00080 	bic	r0, r0, #128, 0	; 0x80
  6c:	e121f000 	msr	CPSR_c, r0
    return t;
}
  70:	e12fff1e 	bx	lr

00000074 <call_static>:

int call_static(void) {
  74:	e92d4010 	push	{r4, lr}
    static int y = 1;

    disable();
    y += 1;
  78:	e59f202c 	ldr	r2, [pc, #44]	; ac <call_static+0x38>
    disable();
  7c:	ebfffffe 	bl	54 <disable>
    y += 1;
  80:	e5923000 	ldr	r3, [r2]
    disable();
    y += 1;
    enable();

    disable();
    y += 1;
  84:	e2833003 	add	r3, r3, #3, 0
    enable();
  88:	ebfffffe 	bl	64 <enable>
    disable();
  8c:	ebfffffe 	bl	54 <disable>
    enable();
  90:	ebfffffe 	bl	64 <enable>
    disable();
  94:	ebfffffe 	bl	54 <disable>
    y += 1;
  98:	e5823000 	str	r3, [r2]
    enable();
  9c:	ebfffffe 	bl	64 <enable>

    return y;
}
  a0:	e8bd4010 	pop	{r4, lr}
  a4:	e1a00003 	mov	r0, r3
  a8:	e12fff1e 	bx	lr
  ac:	00000000 	.word	0x00000000

000000b0 <sw_int_off>:

volatile unsigned sw_int_is_on = 1;

__attribute__ ((__noinline__)) unsigned sw_int_off(void) {
    unsigned t = sw_int_is_on;
    sw_int_is_on = 0;
  b0:	e3a02000 	mov	r2, #0, 0
    unsigned t = sw_int_is_on;
  b4:	e59f3008 	ldr	r3, [pc, #8]	; c4 <sw_int_off+0x14>
  b8:	e5930004 	ldr	r0, [r3, #4]
    sw_int_is_on = 0;
  bc:	e5832004 	str	r2, [r3, #4]
    return t;
}
  c0:	e12fff1e 	bx	lr
  c4:	00000000 	.word	0x00000000

000000c8 <sw_int_on>:
__attribute__ ((__noinline__)) void sw_int_on(void) {
    // enable interrupts
    sw_int_is_on = 1;
  c8:	e3a02001 	mov	r2, #1, 0
  cc:	e59f3004 	ldr	r3, [pc, #4]	; d8 <sw_int_on+0x10>
  d0:	e5832004 	str	r2, [r3, #4]
}
  d4:	e12fff1e 	bx	lr
  d8:	00000000 	.word	0x00000000

000000dc <call_static_sw_int>:

int call_static_sw_int(void) {
  dc:	e92d4010 	push	{r4, lr}
    static int y = 1;

    sw_int_off();
    y += 1;
  e0:	e59f402c 	ldr	r4, [pc, #44]	; 114 <call_static_sw_int+0x38>
    sw_int_off();
  e4:	ebfffffe 	bl	b0 <sw_int_off>
    y += 1;
  e8:	e5941008 	ldr	r1, [r4, #8]
    sw_int_off();
    y += 1;
    sw_int_on();

    sw_int_off();
    y += 1;
  ec:	e2811003 	add	r1, r1, #3, 0
    sw_int_on();
  f0:	ebfffffe 	bl	c8 <sw_int_on>
    sw_int_off();
  f4:	ebfffffe 	bl	b0 <sw_int_off>
    sw_int_on();
  f8:	ebfffffe 	bl	c8 <sw_int_on>
    sw_int_off();
  fc:	ebfffffe 	bl	b0 <sw_int_off>
    y += 1;
 100:	e5841008 	str	r1, [r4, #8]
    sw_int_on();
 104:	ebfffffe 	bl	c8 <sw_int_on>

    return y;
}
 108:	e8bd4010 	pop	{r4, lr}
 10c:	e1a00001 	mov	r0, r1
 110:	e12fff1e 	bx	lr
 114:	00000000 	.word	0x00000000

00000118 <b>:

__attribute__ ((__noinline__)) void b(void) {
    asm volatile ("" : : : "memory");
}
 118:	e12fff1e 	bx	lr

0000011c <static_barrier>:


int static_barrier(void) {
 11c:	e92d4010 	push	{r4, lr}
    static int y = 1;

    b();
    y += 1;
 120:	e59f3028 	ldr	r3, [pc, #40]	; 150 <static_barrier+0x34>
    b();
 124:	ebfffffe 	bl	118 <b>
    y += 1;
 128:	e593000c 	ldr	r0, [r3, #12]
    b();
    y += 1;
    b();

    b();
    y += 1;
 12c:	e2800003 	add	r0, r0, #3, 0
    b();
 130:	ebfffffe 	bl	118 <b>
    b();
 134:	ebfffffe 	bl	118 <b>
    b();
 138:	ebfffffe 	bl	118 <b>
    b();
 13c:	ebfffffe 	bl	118 <b>
    y += 1;
 140:	e583000c 	str	r0, [r3, #12]
    b();
 144:	ebfffffe 	bl	118 <b>

    return y;
}
 148:	e8bd4010 	pop	{r4, lr}
 14c:	e12fff1e 	bx	lr
 150:	00000000 	.word	0x00000000

00000154 <global_barrier>:

unsigned y;
int global_barrier(void) {
 154:	e92d4010 	push	{r4, lr}

    b();
    y += 1;
 158:	e59f3044 	ldr	r3, [pc, #68]	; 1a4 <global_barrier+0x50>
    b();
 15c:	ebfffffe 	bl	118 <b>
    y += 1;
 160:	e5932000 	ldr	r2, [r3]
 164:	e2822001 	add	r2, r2, #1, 0
 168:	e5832000 	str	r2, [r3]
    b();
 16c:	ebfffffe 	bl	118 <b>

    b();
 170:	ebfffffe 	bl	118 <b>
    y += 1;
 174:	e5932000 	ldr	r2, [r3]
 178:	e2822001 	add	r2, r2, #1, 0
 17c:	e5832000 	str	r2, [r3]
    b();
 180:	ebfffffe 	bl	118 <b>

    b();
 184:	ebfffffe 	bl	118 <b>
    y += 1;
 188:	e5932000 	ldr	r2, [r3]
 18c:	e2822001 	add	r2, r2, #1, 0
 190:	e5832000 	str	r2, [r3]
    b();
 194:	ebfffffe 	bl	118 <b>

    return y;
}
 198:	e8bd4010 	pop	{r4, lr}
 19c:	e5930000 	ldr	r0, [r3]
 1a0:	e12fff1e 	bx	lr
 1a4:	00000000 	.word	0x00000000
